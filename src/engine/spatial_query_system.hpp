/**
 * @file spatial_query_system.hpp
 * @author Zoheb Shujauddin (zoheb2424@gmail.com)
 * @brief The file containing classes related to the spatial query system, which uses simplified geometrical data and spatial indexing data structures to answer spatial queries generated by other parts of the program.
 * @version 0.3.2
 * @date 2025-09-10
 * 
 */

#ifndef FOOLSENGINE_SPATIALQUERYSYSTEM_H
#define FOOLSENGINE_SPATIALQUERYSYSTEM_H

#include <memory>
#include <array>

#include "spatial_query_octree.hpp"
#include "scene_system.hpp"
#include "core/ecs_world.hpp"
#include "model.hpp"
#include "light.hpp"

namespace ToyMaker {

    /**
     * @brief The spatial query system, an ECS System that tracks and updates spatial query data for objects in the scene, and which exposes spatial query methods.
     * 
     * It is presently implemented as an octree, and only answers questions that take the form of a Ray or an AABB.
     * 
     */
    class SpatialQuerySystem: public System<SpatialQuerySystem, std::tuple<Transform, ObjectBounds>, std::tuple<SceneHierarchyData, AxisAlignedBounds>> {
    public:
        explicit SpatialQuerySystem(std::weak_ptr<ECSWorld> world):
        System<SpatialQuerySystem, std::tuple<Transform, ObjectBounds>, std::tuple<SceneHierarchyData, AxisAlignedBounds>>{world} 
        {}

        /**
         * @brief Gets the system type string associated with this class.
         * 
         * @return std::string This class' system type string.
         * 
         */
        static std::string getSystemTypeName() { return "SpatialQuerySystem"; }

        /**
         * @brief A subsystem of the SpatialQuery system which tracks StaticModel objects in the scene and updates the position and shapes of their associated object bounds accordingly.
         * 
         */
        class StaticModelBoundsComputeSystem: public System<StaticModelBoundsComputeSystem, std::tuple<std::shared_ptr<StaticModel>>, std::tuple<ObjectBounds>> {
        public:
            explicit StaticModelBoundsComputeSystem(std::weak_ptr<ECSWorld> world):
            System<SpatialQuerySystem::StaticModelBoundsComputeSystem, std::tuple<std::shared_ptr<StaticModel>>, std::tuple<ObjectBounds>> { world }
            {}

            /**
             * @brief The system type string for this class.
             * 
             * @return std::string This class' system type string.
             */
            static std::string getSystemTypeName() { return "SpatialQuerySystem::StaticModelBoundsComputeSystem"; }
        private:
            /**
             * @brief Computes object bounds for an entity as soon as its enabled for this system.
             * 
             * @param entityID The entity whose object bounds should be recomputed.
             */
            void onEntityEnabled(EntityID entityID) override;

            /**
             * @brief Computes object bounds for an entity when it has moved or been scaled.
             * 
             * @param entityID The entity whose object bounds should be recomputed.
             */
            void onEntityUpdated(EntityID entityID) override;

            /**
             * @brief The method responsible for actually recomputing an entity's object bounds.
             * 
             * @param entityID The entity whose object bounds are being recomputed.
             */
            void recomputeObjectBounds(EntityID entityID);
        };

        /**
         * @brief A subsystem of the spatial query system responsible for tracking light volumes and recomputing their ObjectBounds accordingly.
         * 
         * @todo This sort of makes it so that an object with LightEmissionData and StaticModel components gets conflicting results for ObjectBounds.  Do we want to allow entities to have both?  If not, should we do something to explicitly prevent it?
         * 
         */
        class LightBoundsComputeSystem: public System<LightBoundsComputeSystem, std::tuple<LightEmissionData>, std::tuple<ObjectBounds>> {
        public:
            explicit LightBoundsComputeSystem(std::weak_ptr<ECSWorld> world):
            System<SpatialQuerySystem::LightBoundsComputeSystem, std::tuple<LightEmissionData>, std::tuple<ObjectBounds>>{world}
            {}
            /**
             * @brief Gets the system type string associated with this class.
             * 
             * @return std::string This system's system type string.
             */
            static std::string getSystemTypeName() { return "SpatialQuerySystem::LightBoundsComputeSystem"; }
        private:
            /**
             * @brief Updates a light entity's bounds when it has just been made active.
             * 
             * @param entityID The entity that was just made active.
             */
            void onEntityEnabled(EntityID entityID) override;

            /**
             * @brief Updates a light entity's bounds when its position or emissive properties were updated.
             * 
             * @param entityID The light entity being updated.
             */
            void onEntityUpdated(EntityID entityID) override;

            /**
             * @brief The method responsible for actually recomputing the light entity's object bounds.
             * 
             * @param entityID The entity ID of the object.
             */
            void recomputeObjectBounds(EntityID entityID);
        };

        /**
         * @brief Returns a list of entities (by their IDs) overlapping a search AABB.
         * 
         * @param searchBounds The AABB defining the search region.
         * @return std::vector<std::pair<EntityID, AxisAlignedBounds>> The list of entities overlapping with the search region.
         */
        std::vector<std::pair<EntityID, AxisAlignedBounds>> findEntitiesOverlapping(const AxisAlignedBounds& searchBounds) const;

        /**
         * @brief Returns a list of entities (by their IDs) intersecting a search ray.
         * 
         * @param ray The ray intersecting which a list of entities should be found.
         * @return std::vector<std::pair<EntityID, AxisAlignedBounds>> A list of entities intersected by the query ray.
         */
        std::vector<std::pair<EntityID, AxisAlignedBounds>> findEntitiesOverlapping(const Ray& ray) const;

        /**
         * @brief Gets a list of nodes (by their base class pointers) intersecting a search ray.
         * 
         * @param searchRay The ray intersecting which a list of nodes should be found.
         * @return std::vector<std::shared_ptr<SceneNodeCore>> A list of nodes intersecting the search ray.
         */
        std::vector<std::shared_ptr<SceneNodeCore>> findNodesOverlapping(const Ray& searchRay);

        /**
         * @brief Gets a list of nodes which overlap some search region (in the form of an AABB).
         * 
         * @param searchBounds The search region (as an AABB).
         * @return std::vector<std::shared_ptr<SceneNodeCore>> The list of nodes contained by or overlapping the search region.
         */
        std::vector<std::shared_ptr<SceneNodeCore>> findNodesOverlapping(const AxisAlignedBounds& searchBounds);

    private:
        /**
         * @brief Updates the axis aligned bounds of an entity, based on its ObjectBounds.
         * 
         * @param entity The entity whose axis aligned bounds are being updated.
         */
        void updateBounds(EntityID entity);

        /**
         * @brief Triggers the destruction of any presently existing octree and replaces it with a new one.
         * 
         */
        void rebuildOctree();

        /**
         * @brief Marks this system as requiring initialization on the nearest update.
         * 
         */
        void onSimulationActivated() override;

        /**
         * @brief Initializes the tree if necessary, and recomputes octree position for entities whose ObjectBounds were updated.
         * 
         * @param timestepMillis The time by which the simulation will be advanced this simulation frame.
         */
        void onSimulationStep(uint32_t timestepMillis) override;

        /**
         * @brief Marks this entity as requiring an octree update on the nearest simulation step.
         * 
         * @param entityID The entity in need of an update.
         */
        void onEntityEnabled(EntityID entityID) override;

        /**
         * @brief Removes this entity from the Octree.
         * 
         * @param entityID The entity being removed.
         */
        void onEntityDisabled(EntityID entityID) override;

        /**
         * @brief Marks this entity as requiring an octree update on the nearest simulation step.
         * 
         * @param entityID The entity in need of an AABB update.
         */
        void onEntityUpdated(EntityID entityID) override;

        /**
         * @brief Pointer to the octree, the data structure responsible for spatially indexing scene objects.
         * 
         */
        std::unique_ptr<Octree> mOctree { nullptr };

        /**
         * @brief A list of entities whose AABBs should be recomputed at the next simulation step.
         * 
         */
        std::set<EntityID> mComputeQueue {};

        /**
         * @brief Whether a fresh Octree should be built for this system as soon as possible.
         * 
         */
        bool mRequiresInitialization { true };
    };

    // Prevent enabling and disabling of spatial query related systems, leave their management entirely to 
    // the scene system
    template <>
    inline void SceneNodeCore::setEnabled<SpatialQuerySystem>(bool) {/* pass */}
    template <>
    inline void SceneNodeCore::setEnabled<SpatialQuerySystem::LightBoundsComputeSystem>(bool) {/* pass */}
    template <>
    inline void SceneNodeCore::setEnabled<SpatialQuerySystem::StaticModelBoundsComputeSystem>(bool) {/* pass */}

    template <>
    inline void SceneNodeCore::updateComponent<AxisAlignedBounds>(const AxisAlignedBounds& axisAlignedBoxBounds) {
        (void)axisAlignedBoxBounds; // prevent unused parameter warnings
        assert(false && "Cannot update a scene node's WorldBounds component");
    }
    template<>
    inline void SceneNodeCore::updateComponent<ObjectBounds>(const ObjectBounds& objectBounds) {
        (void)objectBounds; // prevent unused parameter warnings
        assert(false && "Cannot update a scene node's ObjectBounds component");
    }
    template <>
    inline void SceneNodeCore::removeComponent<AxisAlignedBounds>() {
        assert(false && "Cannot remove a scene node's AABBTreeNode component");
    }
    template <>
    inline void SceneNodeCore::removeComponent<ObjectBounds>() {
        assert(false && "Cannot remove a scene node's ObjectBounds component");
    }
}

#endif
